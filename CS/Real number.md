# Real number
본 내용은 [양태환](https://github.com/ythwork)님의 저서 **컴퓨터 사이언스 부트캠프 with 파이썬** 을 읽고 요약정리한 내용

## 1. 실수 연산의 함정
왜 아래와 같은 현상이 발생하는 걸까?
```python
a = .01
result = .0

for _ in range(100):
    result += a
else:
    print(result)
```

```bash
a = .015625
result = .0

for _ in range(100):
    result += a
else:
    print(result)
```

```python
1.5625
```

## 2. 부동소수점
컴퓨터는 **실수(real number)** 를 **부동소수점(floating-point)** 로 표현한다. 부동소수점이란 이름은 아래와 같이 실수를 표현할 수 있다는 거에 기인하여 이름이 붙었다.

$$
123.456 = 1.23456 \times 10^{2}, 12.3456 \times 10^{1}, 1234.56 \times 10^{-1}, 12345.6 \times 10^{-2}
$$

## 3. 단정도와 배정도
* 단정도(single-precision) : 실수를 32비트(4바이트)로 표현하며 부호 1비트, 지수부 8비트, 가수부 23비트로 구성됨
* 배정도(double-precision) : 실수를 64비트(8바이트)로 표현하며 부호 1비트, 지수부 11비트, 가수부 52비트로 구성, ***실수를 표현하는 데 사용하는 비트 수가 단정도의 두 배인 만큼 정밀도가 높으며, Python은 배정도를 사용한다.***

이는 메모리에 저장하는 형식이다. 코드로도 확인할 수 있다.

```python
import sys
print(sys.float_info)
```

```bash
# dig : 배정도로 표현할 수 있는 10진수의 자리수
# mant_dig : 가수부 비트 + 정규화에 따른 1비트 = 53비트, 
# epsilon이 중요
sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)
```

배정도 부동소수점으로 표현할 수 있는 가장 큰 수, 가장 작은 수는 아래와 같다.

```python
import sys
print(sys.float_info.max, sys.float_info.min)
```

```bash
# 여기서 e는 지수를 뜻하는 exponent의 줄임말
1.7976931348623157e+308 2.2250738585072014e-308
```

## 4. 1바이트 실수 자료형 설계하기
실수 표현방식은 아래와 같다.

$$
\pm \ 1.man_{(2)} \times 2^{exp-bias}
$$

$1.man$ 은 가수(mantissa/fraction), 2는 밑수(base), exp-bias는 지수(exponent)를 의미한다. ***위의 수식을 이용해, 7.75라는 10진 수 실수를 1바이트 부동소수점으로 표현하는 것은 아래의 과정을 거친다.***

### 4.1 10진수 실수를 2진수 실수로 바꾸기
10진수 실수 7.75를 2진수 실수로 바꾸는 과정은 아래와 같다.

1. 10진수 실수 7.75를 2의 거듭제곱의 합으로 쪼갠다.
	
	$7.75 \rightarrow 4 + 2 + 1 + 0.5 + 0.25$ 

	$7.75 \rightarrow 2^{2} + 2^{1} + 2^{0} + 2^{-1} + 2^{-2}$

2. 지수를 1과 0을 이용해 표현한다.

	$7.75 \rightarrow 1 \times 2^{2} + 1 \times 2^{1} + 1 \times 2^{0} + 1 \times2^{-1} + 1 \times 2^{-2}$

3. 2의 거듭제곱 수를 제외하고 앞의 수 1과 0만 모아 나열한다.

$$
111.11_{(2)}
$$

### 4.2 정규화
**정규화(normalization)** 란 소수점 왼쪽에 위치한 가수 부분을 밑수보다 작은 자연수가 되도록 만드는 것이다. $111.11_{(2)}$ 를 정규화하려면 2진수의 밑수는 2이므로 2보다 작은 자연수는 1밖에 없으므로, 2진수의 경우 소수점 왼쪽의 가수부분은 항상 1이된다.

$$
111.11_{(2)} \rightarrow 1.1111_{(2)} \times 2^{2}
$$

### 4.3 메모리구조
정규화된 2진수 부동소수점 수 $1.1111_{(2)} \times 2^{2}$ 를 보면 가수에서 man 부분은 1111이고, exp-bias는 2이다. 1바이트의 메모리 구조를 아래와 같이 정하고 저장해보자.

$$
0 \ 0000 \ 000 \newline
부호(sign) \ 지수부(exp) \ 가수부에서 \ man에 \ 해당되는 \ 부분
$$

* 첫 번째 비트 : 부호, 0이면 양수, 1이면 음수
* 가운데 4비트 : 지수부, exp 값을 저장
	+ 지수부에는 부호비트가 존재하지 않는다. 
	+ 0~15까지의 양수를 표현할 수 있다.
	+ 음수지수도 필요하므로 bias를 7로 두고 지수부(exp)에서 bias를 뺀 값을 실제 지수로 사용
	+ $bias = 2^{지수부의 비트수 - 1} - 1$
* 맨 뒤 3비트 : 가수부, man 값을 저장

***$1.1111_{(2)} \times 2^{2}$ 를 위에서 정한 1바이트의 메모리 구조에 저장하는 과정은 아래와 같다.***

* 부호비트는 0
* $exp - bias = 2$ 이면서 $bias =7$ 이므로, $ exp = 9 $ 이며 exp를 2진수로 바꾸면 $1001_{(2)}$
* 가수부에서 man에 해당되는 부분은 3비트만 할당되어있는데, 실제 man에 해당하는 부분은 1111, 이 경우 뒷자리 1을 생략한다. 즉 $1.111_{(2)} \times 2^{2}$ 로 본다.

이 과정을 거치면 10진수 실수 7.75를 우리가 정한 1바이트 메모리 구조에 아래와 같이 저장할 수 있다.

$$
0 \ 1001 \ 111 \rightarrow 0100 \ 1111
$$

***10진수 실수 7.75를 위와 같이 1바이트 메모리 구조에 저장하고, 이를 16진수로 나타내면 0x4f이다.***

### 4.4 1바이트 부동소수점의 표현 범위

위에서 설계한 1바이트 부동소수점으로 표현할 수 있는 가장 작은 수와 가장 큰 수는 아래와 같다.

(단, 지수부 비트가 모두 0일 때($2^{-7}$), 지수부 비트가 모두 1일 때($2^{8}$)는 0.0, 정규화 불가능, 무한대, NaN(Not a Number) 등은 제외)

* 표현할 수 있는 가장 작은 수 (지수부가 $0001$)
	+ $1.000_{(2)} \times 2^{-6} = 0.015625$
* 표현할 수 있는 가장 큰 수 (지수부가 $1110​$)
	+ $1.111_{(2)} \times 2^{7} = 240$

### 4.5 1바이트 부동소수점의 정밀도

10진수 실수 7.75를 우리가 설계한 1바이트 메모리구조에 담기위해서 2진수 실수로 바꾼 뒤, 부동소수점표현을 쓰고, 정규화를 하면 $1.111_{(2)} \times 2^{2}$ 가 된다. 이렇게 됬을 경우 우리는 1바이트 메모리구조에 실제로는 $1 \ 1001 \ 111 \rightarrow 1100 \ 1111$ 의 형태로 저장하는 것이고, 16진수로 표현하면 0x4f이다. ***위에서 설계한 1바이트 메모리구조는 7.75 실수를 완벽하게 표현하지는 못한다.***

$$
1.111_{(2)} \times 2^{2} = 111.1_{(2)} = 1 \times 2^{2} \ +1 \times 2^{1} + 1 \times 2^{0} + 1 \times 2^{-1} = 7.5
$$

## 5. 정밀도에 대한 고찰
### 5.1 엡실론
실수 자료형에서 **엡실론(epsilon)** 이란 1.0과 그 다음으로 **표현 가능한 수(representable float)** 의 사이의 차이를 말한다. ***Python에서는 실수를 표현함에 있어서 배정도를 쓴다는 사실을 기억한 채로 코드로 확인하면 아래와 같다.***

```python
import sys 
print(sys.float_info.epsilon)
```

```bash
2.220446049250313e-16
```

Python은 실수 표현에 있어 배정도를 사용하므로, $1.man_{(2)} \times 2^{exp-bias}$ 의 ***가수부 $1.man$에서  $man$에 해당하는 부분에 52비트를 활용한다.***

따라서 위의 엡실론에 대한 출력값은 아래의 과정을 통해서 나온 것이다.

$$
1.0000 \cdots 0000_{(2)}(0: 52개) \times 2^{0}
$$

배정도에서 1.0 다음으로 **표현할 수 있는 수(representable float)** 은 다음과 같다.

$$
1.0000 \cdots 0001_{(2)}(0: 51개, 1: 마지막 비트) \times 2^{0}
$$

두 수의 차이는 다음과 같다.

$$
0.0000 \cdots 0001_{(2)}(0: 51개, 1: 마지막 비트) \times 2^{0}
$$

이 수를 10진수로 바꾸면 엡실론 값이 나온다.

$$
2.20446049250313 \times 10^{-16}
$$

### 5.2 엡실론과 정밀도
10진수 실수 9.25를 2진수 실수로 바꾸고, 부동소수점으로 표현하면 $1.00101_{(2)} \times 2^{3}$  이며 ***이 식에서 지수부분인 $2^{3}$ 을 떼내어 엡실론을 곱하면, 이 실수와 다음 표현 가능한 수 사이의 차이를 구할 수 있다.***

```python
import sys
ep = sys.float_info.epsilon
a = 9.25
diff = (2**3) * ep
print(diff)
```

```bash
1.7763568394002505e-15
```

```python
b = a + diff
print(b)
print(a == b)
```

```bash
9.250000000000002
False
```

다음 표현 가능한 수의 차이인  `diff` 보다 더 적은 값을 더하면 이를 표현하지 못함을 알 수 있다.

```python
print(a)
half_diff = diff / 2
print(half_diff)
c = a + half_diff
print(a==c)
```

```bash
9.25
8.881784197001252e-16
True
```
