# Integer
본 내용은 [양태환](https://github.com/ythwork)님의 저서 **컴퓨터 사이언스 부트캠프 with 파이썬** 을 읽고 요약정리한 내용

* Reference
	+ <https://ko.wikihow.com/16%EC%A7%84%EC%88%98%EB%A5%BC-2%EC%A7%84%EC%88%98%EC%99%80-10%EC%A7%84%EC%88%98%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EB%8A%94-%EB%B2%95>

## 1. 컴퓨터에서 수를 표현하는 방법
수를 표현하는 방법을 **기수법(numeral system)** 이라고 하며, **밑수(base)** 를 정하면 밑수 개수만큼의 **숫자(digit)** 를 사용해 수를 나타낼 수 있다.

### 1.1 10진수
10진수는 수를 표현하는 데 숫자를 총 열 개 사용한다. 밑수는 10이고 0부터 9까지의 총 열 개의 숫자로 모든 수를 표현한다.

$$
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
$$

### 1.2 2진수
2진수는 수를 표현하는 데 숫자 0과 1만 사용한다. 컴퓨터가 인식할 수 있는 표현방법이다.

$$
0, 1
$$

### 1.3 16진수
16진수는 수를 표현하는 데 숫자를 총 열여섯 개 사용한다. 아래와 같다. 보통 많은 자리의 2진수 숫자를 4개씩 짤라서 16진수로 표현한다.

$$
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f
$$

16진수 $a, b ,c ,d ,e ,f$ 를 2진수로 바꿔보면 아래와 같다.

$$
a = 1010_{(2)}, b = 1011_{(2)}, c = 1100_{(2)}, d = 1101_{(2)}, e = 1110_{(2)}, f = 1111_{(2)}
$$

## 2. 10진수를 2진수로

10진수를 2진수로 바꿀 때는 다음과 같이 바꾼다. 예를 들어 25를 2진수로 바꿔보자.

1. 25를 2의 거듭제곱의 합으로 쪼갠다

  $25 \rightarrow 16+9$

  $25 \rightarrow 16+8+1=2^{4}+2^{3}+2^{0}$

2. $2^{2}$ 나 $2^{1}$ 처럼 중간에 빠진 지수는 0을 이용해 표현한다.

$$
25 \rightarrow 1 \times 2^{4} + 1 \times 2^{3} + 0 \times 2^{2} + 0 \times 2^{1} + 1 \times 2^{0}
$$

3. 2의 거듭제곱 수를 제외하고 앞의 수 1과 0만 모아 나열한다.

$$
11001_{(2)}
$$

Python으로 확인해보면 아래와 같다.

```python
a = 25
print(bin(a))
```

```bash
0b11001 # 맨앞의 0b는 2진수를 의미하는 binary
```

## 3. 2진수를 10진수로
2진수를 10진수로 바꿀 때는 아래와 같이 바꾼다.

$$
11001_{(2)} \rightarrow 1 \times 2^{4} + 1 \times 2^{3} + 0 \times 2^{2} + 0 \times 2^{1} + 1 \times 2^{0} = 25
$$

## 4. 16진수를 2진수로
16진수 한 자리는 0부터 f까지 최대 10진수 15까지 표현할 수 있다. 16진수 f는 10진수로는 15이며 이를 2진수로 변환하면 $1111_{(2)}$ 이다. ***즉 16진수 한 자리는 2진수 네 자릿수까지 표현할 수 있다.*** 16진수는 즉 4비트를 이용하여 표현한다. 예를 들어 16진수 3을 2진수로 바꿔보자.

1. 16진수 3은 10진수 3과 같으므로, 10진수에서 2진수로 바꾸는 방법을 활용한다.

	$3_{(16)}= 3 \rightarrow 2 + 1$

	$3_{(16)}= 3 \rightarrow 2 + 1 = 1 \times 2^{1} + 1 \times 2^{0}$

2. 16진수 한자리는 2진수 네 자릿수까지 표현할 수 있으므로, 4비트로 표현한다. 빠진 지수는 0을 이용해 표현한다.

	$$
	3 \rightarrow 0 \times 2^{3} + 0 \times 2^{2} + 1 \times 2^{1} + 1 \times 2^{0}
	$$

3. 2의 거듭제곱 수를 제외하고 앞의 수 1과 0만 모아 나열한다.

$$
  0011_{(2)}
$$

## 5. 코딩으로 확인하는 진수 변환
```python
origin = [0x0, 0x1, 0x2, 0x3, 0x4,
          0x5, 0x6, 0x7, 0x8, 0x9,
          0xa, 0xb, 0xc, 0xd, 0xe, 0xf]
trans = list(map(lambda elm : bin(elm), origin))

for idx in range(len(origin)):
    print('16진수 : {} ---> 2진수 : {}'.format(hex(origin[idx]), trans[idx]))
```

```bash
16진수 : 0x0 --> 2진수 : 0b0     #0b0000
16진수 : 0x1 --> 2진수 : 0b1     #0b0001
16진수 : 0x2 --> 2진수 : 0b10    #0b0010
16진수 : 0x3 --> 2진수 : 0b11    #0b0011
16진수 : 0x4 --> 2진수 : 0b100   #0b0100
16진수 : 0x5 --> 2진수 : 0b101   #0b0101
16진수 : 0x6 --> 2진수 : 0b110   #0b0110
16진수 : 0x7 --> 2진수 : 0b111   #0b0111
16진수 : 0x8 --> 2진수 : 0b1000
16진수 : 0x9 --> 2진수 : 0b1001
16진수 : 0xa --> 2진수 : 0b1010
16진수 : 0xb --> 2진수 : 0b1011
16진수 : 0xc --> 2진수 : 0b1100
16진수 : 0xd --> 2진수 : 0b1101
16진수 : 0xe --> 2진수 : 0b1110
16진수 : 0xf --> 2진수 : 0b1111
```

예를 들어, 8비트 컴퓨터의 메모리 주소가 2진수 $0010 1101_{(2)}$ 라면 2진수 네 자릿수를 16진수 한 자릿수로 표현할 수 있으므로, $2d_{(16)}$ 으로 나타낼 수 있다. 보통 메모리 주소를 나타낼 때는 16진수를 활용한다.

```python
address_8bit = 0b00101101
print(hex(address_8bit))
```

```bash
0x2d
```

32비트 컴퓨터의 메모리 주소는 서른두 자릿수의 2진수 수가아닌 여덟 자릿수의 16진수 수를 이용하여 표현한다.

```python
address_32bit = 0x1234abcd
print(bin(address_32bit))
```

```python
0b10010001101001010101111001101
# 0b1/0010/0011/0100/1010/1011/1100/1101
# Python에서는 0으로 구지 채우지 않아서 표현하므로 4자릿수로 오른쪽에서 왼쪽으로 짤라 나갔을 때, 마지막에
# 남는 1은 0001로 봐야한다.
```

## 6. 양의 정수
컴퓨터는 **정수(integer)** 를 1바이트, 2바이트, 4바이트, 8바이트 등 다양한 크기로 저장한다. ***예를 들어, 메모리의 1바이트에 정수 25를 저장할 경우 아래와 같다.***

* 부호를 나타내는 데 1비트를 활용한다.
  + 맨 앞의 비트가 0이면 양수, 1이면 음수
* 10진수 25를 2진수로 $11001_{(2)}$ 변환, 빈곳으로 0으로 채운다.
* 결론적으로 메모리에 아래와 같이 저장한다.

$$
0001 \ 1001_{(2)}
$$

메모리에 1바이트로 정수를 저장할 경우, 8비트이므로 256개의 정수를 표현하여 할 수 있으며, -128 ~ 127의 정수를 저장할 수 있다. 음의 정수를 메모리에 저장할 때는, 양의 정수와 방식이 많이 달라진다.

## 7. 음의 정수
컴퓨터는 음수를 **보수(complement)** 형태로 저장한다.

### 7.1 보수의 개념
**보수(complement)** 는 쉽게 말해 보충해주는 수로 예를 들면 아래와 같다.

* 10진수에서 26의 9의 보수와 10의 보수를 구한다고 하면
  + $26 + 73 = 99$ 이므로 26의 9의 보수는 73 
  + 26의 10의 보수는 $73 + 1 = 74$ 이다.

### 7.2 2의 보수
컴퓨터는 음수를 표현할 때, 2의 보수를 사용한다. 예를들어 2진수 $1010_{(2)}$ 의 2의 보수를 구하려면 아래와 같이 구한다.

* 2진수에서 $1010_{(2)}$ 의 1의 보수를 먼저 구한다.
  + $1010_{(2)} + 0101_{(2)} = 1111_{(2)}$ 이므로 1의 보수는 $0101_{(2)}$
  + 위 과정을 그냥 각 자리수에서 반전시킨다고 생각해도 된다.
* 구한 1의 보수에 1 ($0001_{(2)}$)을 더한다.
  + $0101_{(2)} + 0001_{(2)} = 0110_{(2)}$ 이므로 2의 보수는 $0110_{(2)}$

### 7.3 음수의 표현

1바이트로 정수로 표현할 경우, 음의 정수인 -4는 아래와 같이 표현된다.

* 먼저 양의 정수 4를 2진수로 $0000 \ 0100_{(2)}$ 로 표현한다.
* 2진수에서의 1의 보수를 구한다.
	+ $0000 \ 0100_{(2)} + 1111 \ 1011_{(2)} = 1111 \ 1111_{(2)}$ 이므로 1의 보수는 $1111 \ 1011_{(2)}$
* 구한 1의 보수에 1 ($0000 \ 0001_{(2)}$)을 더한다.
	+ $1111 \ 1011_{(2)} + 0000 \ 0001_{(2)} = 1111 \ 1100_{(2)}$ 이므로 2의 보수는 $1111 \ 1100_{(2)}$
* -4를 $1111 \ 1100_{(2)}$ 표현하여 메모리 1바이트에 저장한다.

코드로 확인해보면 아래와 같다.
```python
a = -4
print(a.to_bytes(1, byteorder = 'little', signed = True))
```

```bash
b'\xfc'
```

```python
print(bin(0xfc))
```

```bash
0b11111100
```

### 7.4 2의 보수로 표현하는 이유
컴퓨터에서 음의 정수를 2의 보수로 표현하는 이유는 아래와 같다. 메모리 1바이트에 정수를 저장하는 경우로 생각해보면

* 양의 정수와 음의 정수를 모두 양의 정수를 저장하는 방식으로 저장한다고 하면, 0을 표현하는 방식이 $0000 \ 0000_{(2)}$, $1000 \ 0000{(2)}$ 두 가지가 된다. 이는 아래의 문제를 발생시킨다.
  + 컴퓨터 입장에서 수 하나를 더 표현할 수 있는 데, 비트 하나를 낭비하게됨
  + 두 수를 비교할 때 CPU에서 뺄셈을 하는데 +0과 -0을 비교하면 결과 값이 예상과 다르게 나옴
* 정수의 뺄셈연산이 다음과 같이 되어 컴퓨터 입장에서 깔끔함, $9 - 4 \rightarrow 9 + (-4)$ 를 함
	+ $0000 \ 1001_{(2)} + 1111 \ 1100_{(2)} = \cancel{1} \ 0000 \ 0101_{(2)}$
	+ 위 처럼 계산하게되며, 계션 결과를 보면 **받아올림(carring)** 이 발생하나, 메모리 1바이트에 정수를 표현하고 있으므로, 이를 버리면됨. 즉 잘 계산이 되었음.

